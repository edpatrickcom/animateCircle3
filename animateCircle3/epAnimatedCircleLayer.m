//
//  epAnimatedCircleLayer.m
//  animateCircle3
//
//  Created by edp on 9/23/14.
//  Copyright (c) 2014 edp. All rights reserved.
//

#import "epAnimatedCircleLayer.h"

@interface epAnimatedCircleLayer ()


@end





@implementation epAnimatedCircleLayer


// angle is the variable that the animation will interpolate over

@dynamic arcAngle;



// drawing/animation properties

@synthesize strokeColor    = _strokeColor;
@synthesize strokeWidth    = _strokeWidth;
@synthesize updateDuration = _updateDuration;
@synthesize circleWidth    = _circleWidth;





// important default values

- (id)init {
    
    self = [super init];
    
    if (self) {
        
        self.bounds = CGRectMake(0, 0, 300, 300);
        
        _strokeColor    = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1];
        _strokeWidth    = 5;
        _updateDuration = 2.0;
        _circleWidth    = 100;
        
        
    }
    
    return self;
}




// make sure that the keypath value "arcAngle" causes display to run


+ (BOOL)needsDisplayForKey:(NSString *)key {
    
    if ([key isEqualToString:@"arcAngle"]) {
        
        return YES;
    
    } else {
        
        return [super needsDisplayForKey:key];
        
    }
    
}




- (void)display {
    
    
    // These NSLogs are useful for watching the interpolation and display process
    // add understanding the difference between the the model layer and the presentation layer.
    
    // this is the value set in the model layer
    // it is the last value set
    //
    // NSLog(@"arcAngle %.1f", self.arcAngle);
    
    
    // this is the value in the presentation layer
    // it will interpolate between the initial value
    // and the value that was just set
    //
    // NSLog(@"arcAngle %.1f", [[self presentationLayer] arcAngle]);
    
    
    
    
    // get interpolated angle value
    
    float theArcAngle = [self.presentationLayer arcAngle];

    
    
    // Create the backing image context
    
    UIGraphicsBeginImageContextWithOptions(self.bounds.size, NO, 0);

    
    
    // BEGIN CODE GENERATED BY PAINTCODE
    // (which is a very useful program)
    
    
    //// Variable Declarations
    
    CGFloat drawAngle    = theArcAngle;
    
    //// Oval Drawing
    
    CGRect ovalRect = CGRectMake(0, 0, _circleWidth, _circleWidth);
    
    UIBezierPath* ovalPath = UIBezierPath.bezierPath;
    
    [ovalPath
        addArcWithCenter: CGPointMake(CGRectGetMidX(self.bounds), CGRectGetMidY(self.bounds))
        radius: CGRectGetWidth(ovalRect) / 2
        startAngle: -drawAngle * M_PI/180
        endAngle: 0 * M_PI/180
        clockwise: YES];
    
    [_strokeColor setStroke];
    
    ovalPath.lineWidth = _strokeWidth;
    
    [ovalPath stroke];

    // END CODE GENERATED BY PAINTCODE
    
    
    
    
    
    // Once done drawing then set the contents of the layer to be the backing image
    
    self.contents = (id)UIGraphicsGetImageFromCurrentImageContext().CGImage;
    UIGraphicsEndImageContext();

    
    
    
    

    
    
    
}




// generate the animation for the key "arcAngle"
// allow other key values to pass to the super


- (id<CAAction>)actionForKey:(NSString *)event {
    
    
    if ([event isEqualToString:@"arcAngle"]) {
        
        CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:event];
        animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];
        animation.duration = _updateDuration;
        
        // this can be used but starting from the current angle
        //
        // animation.fromValue = @(self.arcAngle);
        
        // in the presentation layer is a little better
        //
        animation.fromValue = @([[self presentationLayer] arcAngle]);
        
        
        return animation;
        
        
    } else {
        
        return [super actionForKey:event];
        
    }
    
    
}




@end
